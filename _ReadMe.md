# 介绍
本脚本用于实现一个迷宫游戏，分为以下部分
1. [ ] 数据结构部分
   1. [x] 迷宫结构的存储数据结构的实现，要求给定某一坐标，可以方便地判断向各方向移动的合法性
   2. [x] 迷宫节点的存储数据结构，要求可以由用户坐标方便地访问迷宫结构的存储数据结构
   3. [x] 已访问节点的数据结构；这是迷宫生成算法所要求的，尽管不是必须的（也可以存储在`*table-map*`数据结构中），但是可以极大地方便程序实现
   4. [ ] 待检查边界的数据结构；这是后两种迷宫生成算法所要求的，也可以改善第一种算法中非尾递归形式的递归调用，使其转化为尾递归形式
2. [x] 迷宫生成的算法的实现
   包括递归调用，可以参考JavaScript迷宫小游戏
   - [x] 随机深度优先算法：一种优先探索最近开启的节点的边界的算法；可以仅依靠非尾递归形式的递归
   - [ ] 随机prim算法：一种为每一个待检查边界生成随机权重的算法
   - [ ] 随机遍历算法：一种随机从待检查边界中选取并检查的算法
3. [ ] 迷宫的渲染
   - [x] 迷宫的结构的渲染
   - [ ] 用户坐标的渲染
   - [ ] 终点坐标的渲染
4. 用户文本交互循环，要求接受用户的输入，执行游戏内的函数（可以参考land of lisp）

# 迷宫与数据结构
## 存储迷宫结构的数据结构
1. Common Lisp内置数组(array)
2. 内层列表内的列表作为迷宫的节点

## 迷宫节点的数据结构
(prev (dir1 dir2 dir2))
1. 其中prev表示上一个节点，即由何方位的相邻节点到达该节点
2. 如果是迷宫生成的起始点，则prev 为'nil
3. dir1, dir2, dir3表示下一节点，即向何方位到达相通的相邻节点
4. 方位均由'w, 'a, 's, 'd表示

### 访问迷宫节点的方法
1. 调用(aref **array** i j)的功能
2. (get-node i-j), 给定(i j)坐标，访问迷宫第i行、第j列节点

## 已开启节点的数据结构
1. 已开启节点即为节点，但是必须为引用方式，而非值方式调用的节点
2. 已开启节点列表即为存储节点的列表
   只需压入和搜索，无需弹出
   - `done-node (node)` 以宏而非函数、push而非cons的形式将节点压入列表
   - `done-node-p (node)` 判断节点是否位于已开启列表中

## 待检查边界的数据结构
1. 以构造函数的形式定义待检查边界的数据结构
   ```lisp
   (defun create-to-edge (i-j dir)
     `(:node-i-j ,i-j :dir ,dir))
   ```
2. 待检查边界列表即为存储边界的列表
   需要压入、弹出
   - `push-todo (i-j dir)` 压入待探索边界
   - `pop-todo ()` 弹出待探索边界

# 迷宫的算法
## 随机深度优先算法
### 递归的实现方式
- 函数的定义
  ```
  init-maze (init-i-j)
   ├ todo-list ()
   └ explore (i-j)
  ```
- 函数的调用
  ```
  init-maze ─ explore ┬ done-node
                      ├ todo-list
                      └ (loop) ─ (if) ┬ add-node-dir-list
                                      ├ set-node-prev
                                      └ [explore]
  ```
  1. 需要在探索一个节点初期就开启该节点
  2. 否则会出现迷宫内部相交的情况，因为初始节点没有任何前继节点为其标记开启
### 基于边界列表压栈的实现方式

## 随机Prim算法

## 随机遍历算法

# 用户交互

# 迷宫的渲染
## 迷宫绘制
- 函数定义
  ```
  draw-maze ()
   └ draw-crossing (i-j)
  ```
- 函数调用
  ```
  draw-maze ─ (dotimes) ┬ (dotimes) ─ (concatenate) ─ draw-crossing
                        └ (concatenate)
  ```
  1. 通过拼接字符来达到绘制整个迷宫的目的
  2. 用两个字符表示迷宫的节点与相邻节点的连通情况
  3. 将四个方向的连通情况转换为枚举值，然后用查表的方法获取
  4. 迷宫节点字符保存在列表中
     ```lisp
     (let (crossing-list '("X " "↑ " "↓ " "│ "
                           "─ " "┘ " "┐ " "┤ "
                           " ─" "└─" "┌─" "├─"
                           "──" "┴─" "┬─" "┼─"))
          '(do something here))
     ```

## 清屏的命令
可以通过转义ANSI字符完成清屏
```lisp
(format t "~c[2J~c[H" #\escape #\escape)
```
1. `~c[2J`向终端发送清屏指令
2. `~c[H`向将光标移动到终端的左上角

